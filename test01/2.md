#找筷子
#CX 小朋友找出了餐厅中所有的筷子，但遗憾的是这些筷子长短不一，而我们都知道
#筷子需要长度一样的才能组成一双，更麻烦的是 CX 找出来的这些筷子数量为奇数，
#但是巧合的是，这些筷子中只有一只筷子是落单的，其余都成双，善良的你，
#可以帮 CX 找出这只落单的筷子的长度吗？

#时间限制 2s
#内存限制
#4.00 MB

#输入格式
#第一行是一个整数，表示筷子的数量 n。
#第二行有 n 个整数，第 i 个整数表示第 i 根筷子的长度 a[i]
​
#数据规模与约定
#对于 30 的数据，保证 n <= 10^5
#对于 100 的数据，保证 1 <= n <= 10^7 + 1 ，1 <= a[i] <= 10^9 

#提示
#请注意数据读入对程序效率造成的影响。
#请注意本题的空间限制为 4 Mb。

#输出格式
#输出一行一个整数表示答案。

#输入1
···
9
2 2 1 3 3 3 2 3 1
···
#输出2
···
2
···

#include<stdio.h>
int x, n, ans;
int main() 
{
    scanf_s("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf_s("%d", &x), ans ^= x;
    printf("%d\n", ans);
}

#失踪的7
#小组的学长学姐们使用阿拉伯数字计数，但是他们又不喜欢使用7，
#所以在小组中数字8其实表示的是自然数中的7，18表示的是自然数中的16，
#他们给这种计数方式取了一个名字，叫做 L 方法。
#下面请计算一下，在正整数n范围以内包含有多少个 L 方法中的数字。
#输入格式
#第一行为正整数t，接下来t行，每行一个正整数n(≤2^32-1)。

#时间限制 1s
#内存限制
#125.00 MB

#输入的是 L 数字
#t≤10000
#输出格式
#对于每个正整数n，输出n以内的 L 数的个数。
#输入 1
···
2
10
20
···
#输出 1
···
9
18
···
#输入 1
···
1
999
···
#输出 1
···
728
···
#include<stdio.h>
#include<math.h>
/*思路:十进制中,1234 = 1*10^3 + 2*10^2 + 3*10^1 + 4*10^0,
去掉了一个数字7,变成了9进制,模拟进制转换
注意点:因为处理的数据范围是(n≤2^32-1),所以说需要用到long long int类型来储存,
为了防止出错,全部设为lld类型
*/
int main() 
{
	long long int num, n;//定义临时变量num和总数字n
	scanf("%lld", &n);
	
	for (int i = 0; i < n; i++)//边读取边处理
	{
		scanf("%lld", &num);
		long long int sum = 0, count = 0,temp;//每次处理前将相关数据重新定义,赋值
		while(num)//当num不为0的时候进行处理
		{
			temp = num % 10;//取num的最右边位数字(第一次取的是个位)
			if (temp < 7)//分支判断,决定计算公式
				sum += temp * pow(9, count);
			else
				sum += (temp-1) * pow(9, count);
			num /= 10;//最右位的数字被处理后就舍去,倒数第二右位变成最右位
			count++;//指数自增
		}
		printf("%lld\n", sum);//输出结果
	}
	return 0;
}